---
layout: post
title: 'How To: Deploying Phoenix Application on Ubuntu'
tag:
- devops
- elixir
- erlang
- phoenix-framework
- web-development
---

<h4>Simple way</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/997/1*tYIa2mPcoZKG1UxADbUcKA.png" /></figure><p>Phoenix is cool, right? You’ve just created your brilliant web application and it works fine on your local machine. It’s awesome, but nobody knows about it. Stop, your friend knows, because you’ve told him in the bar a week ago and he is tied waiting to try it! Hey, it’s time to deploy the app and show it to the entire world…</p><h3><strong>Prerequisite</strong></h3><p>For the purpose of this article we assume that you have the following things ready:</p><ul><li>a Simple <a href="http://phoenixframework.org">Phoenix</a> application working locally</li><li><a href="https://git-scm.com">git</a> repository for the app, hosted on <a href="https://github.com/">GitHub</a> (it can be hosted anywhere, bu I’ll describe configuration process for GitHub)</li><li><a href="https://www.ubuntu.com">Ubuntu</a>, preferably 18.04-LTS, installed and you have a sudo’er user ssh access to it</li></ul><p>For the purpose of this article I use several environmental variables:</p><ul><li><strong>$PROJECT</strong> — your project name, eg. my_project</li><li><strong>$REPO</strong> — your project’s git repository ssh url</li><li><strong>$EMAIL</strong> — your email address</li><li><strong>$DOMAIN</strong> — domain for your app</li></ul><h3><strong>Let’s prepare the ground</strong></h3><p>In order to work properly Phoenix application needs 3 things:</p><ul><li><a href="http://postgresql.org">PostgreSQL</a> or other database to store data</li><li><a href="http://nginx.org">Nginx</a> (or other web server) to serve HTTP(S) requests quickly and secure</li><li><a href="http://www.erlang.org">Erlang</a> and <a href="http://elixir-lang.org">Elixir</a> as runtime environment for Phoenix</li></ul><p>Let’s discuss each point in more details.</p><h3><strong>Installing and Configuring PostgreSQL</strong></h3><p>First of all, let’s install PostgreSQL from Ubuntu software repository.</p><pre>$ sudo apt-get update</pre><pre>$ sudo apt-get install -y postgresql postgresql-contrib</pre><p>After that, we create a role for our app. Don’t use “postgres” role with your app as it gives too much privileges to our app.</p><pre>$ sudo -u postgres createuser -dP ${PROJECT}_app</pre><p>Then we need to change authentication method that is used to connect to Postgres. In either case we’ll get connection errors from postgrex. You can edit this config file with your favourite editor if you like, but this way is quicker if you have default config from repositories.</p><pre>$ sudo sed -i &quot;s/peer$/md5/&quot; /etc/postgresql/*/main/pg_hba.conf</pre><p>Optionaly, you can tune other Postgres options here. But it’s out of spec for this article.</p><p>After all restart Postgres to apply changes in configs.</p><pre>$ sudo systemctl restart postgresql</pre><h3><strong>Installing Erlang and Elixir</strong></h3><p>If you just try to install Erlang and Elixir from system repositories you get it a bit outdated, so I suggest to use ones from <a href="https://www.erlang-solutions.com">Erlang Solutions</a>. Firstly, we need to add them to apt, then update repository and install.</p><pre>$ wget <a href="https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb">https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb</a></pre><pre>$ sudo dpkg -i erlang-solutions_1.0_all.deb</pre><pre>$ sudo apt-get update</pre><pre>$ sudo apt-get install -y esl-erlang elixir</pre><p>In order to successfully build and manage the project we need a bit more packages.</p><pre>$ sudo apt-get install -y tmux git make gcc npm webpack</pre><h3><strong>Brining up the Project</strong></h3><p>It’s time to get your project from git, build it and make running, but, firstly, I want to mention that it’s very bad habit to run web projects from “root” user. So let’s create a user for our app and switch to .</p><pre>$ sudo useradd -m -s /bin/bash $PROJECT</pre><p>Next step is to create a folders for our project and give our user rights to utilise it. It’s up to you where to create it, but I suggest <em>/opt</em> folder as it looks suitable from the point of convention.</p><p>We need 2 folders: one for <strong>code</strong> from git and one for <strong>server specific configuration</strong>.</p><pre>$ sudo mkdir -p /opt/$PROJECT/config</pre><pre>$ sudo chown -R $PROJECT:$PROJECT /opt/$PROJECT</pre><p>Now we switch to the user we created for our project and complete most of project bootstrapping work from it.</p><pre>$ sudo su $PROJECT</pre><pre>(PROJECT) $ ssh-keygen -t rsa -b 4096 -C “$EMAIL”</pre><p>Here you need to add public key from <em>/home/$PROJECT/.ssh/id_rsa.pub</em> to authorised keys that can have access to your git repo through ssh. For GitHub it is called “Deploy keys” and can be added from repo settings page. After that, you can clone, tune and build your project.</p><pre>(PROJECT) $ cd /opt/$PROJECT</pre><pre>(PROJECT) $ git clone ssh://$REPO repo</pre><pre>(PROJECT) $ cp repo/config/prod.secrets.exs.sample config/prod.secrets.exs</pre><p>Now we need to create <em>/opt/$PROJECT/config/prod.secrets.exs</em> and add our Postgres connection settings there and may be other stuff.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d63bc74ec774e4d63a54922f423c6b14/href">https://medium.com/media/d63bc74ec774e4d63a54922f423c6b14/href</a></iframe><p>Replace all variables here with actual values. And go on with compilation and bringing it up.</p><pre>(PROJECT) $ ln -s /opt/$PROJECT/config/prod.secret.exs repo/config/prod.secret.exs</pre><pre>(PROJECT) $ cd repo</pre><pre>(PROJECT) $ export MIX_ENV=prod</pre><pre>(PROJECT) $ mix deps.get</pre><pre>(PROJECT) $ mix compile</pre><pre>(PROJECT) $ mix do ecto.create, ecto.migrate</pre><pre>(PROJECT) $ cd assets &amp;&amp; npm install &amp;&amp; webpack --mode production &amp;&amp; cd ..</pre><pre>(PROJECT) $ mix phx.digest</pre><pre>(PROJECT) $ iex -S mix phx.server</pre><p>If we don’t get an error here, we can press Ctrl-C twice, return to our default user (press Ctrl-D or type exit &lt;CR&gt;) and go on.</p><h3><strong>Configuring system.d to Start the App</strong></h3><p>System.d is the core Ubuntu initialising and service monitoring system. To make our app start automatically on boot we need to configure it. Here is a config for our app.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8a70617eb13a300b2e5080d49657558f/href">https://medium.com/media/8a70617eb13a300b2e5080d49657558f/href</a></iframe><p>You need to change variables here to actual values to make it work.</p><p>After you put this file to <em>/etc/systemd/system/$PROJECT.service</em>, run the following commands to initialise and start it.</p><pre>$ sudo systemctl enable $PROJECT</pre><pre>$ sudo systemctl start $PROJECT</pre><h3><strong>Setting up Nginx and certbot for HTTPS</strong></h3><p>To finish our journey and make our application look professional we need to make it work through secure HTTPS protocol and listen on standard 443 port. To achieve it we need to install and configure Nginx proving our app through ssl and caching static content to enhance load speed and certbot to get free SSL certificated for us.</p><pre>$ sudo apt-get install software-properties-common</pre><pre>$ sudo add-apt-repository universe</pre><pre>$ sudo add-apt-repository ppa:certbot/certbot</pre><pre>$ sudo apt-get update</pre><pre>$ sudo apt-get install -y certbot python-certbot-nginx nginx</pre><p>Let’s configure Nginx to serve our app. Here I assume that Phoenix app is configured to listen on 4000 port (as default configuration). Add this config to <em>/etc/nginx/sites-available/$PROJECT</em>.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d58da2ac7e9edebaf941db2ce9c3ea4b/href">https://medium.com/media/d58da2ac7e9edebaf941db2ce9c3ea4b/href</a></iframe><p>As in all previous config files you need to replace variables with their values.</p><pre>$ sudo ln -s /etc/nginx/sites-available/$PROJECT /etc/nginx/sites-enabled/$PROJECT</pre><pre>$ sudo systemctl restart nginx</pre><p>After that, Nginx is ready to work for us trough insecure http protocol on 80 port. Let’s start it and check if it’s working.</p><p>Now point your browser to the $DOMAIN and check if you see your apps pages. If everything is ok, we are moving to last stage: adding SSL.</p><p>This command should do the job.</p><pre>$ sudo certbot --nginx</pre><p>Now we have our application deployed and working in correct way. To be even more secure it’s recommended to configure firewall to allow only SSH and HTTP(S) ports, but it’s a topic of the other article.</p><h4>PS</h4><p>Dear readers, thank you for your interest and feedback. You are welcome to support this article by clapping, subscribing to the publication or following <a href="http://twitter.com/T0ha666">@T0ha666</a>.</p><p>Do you have a tech startup idea? Or do you need some help with web, mobile or IoT programming?</p><p>Visit <a href="https://3epsilon.pro?utm_source=medium&amp;utm_medium=post&amp;utm_compaign=footer&amp;utm_content=293645f38145">3∑ website</a> and get a great offer from us.</p><p>You can contact me by Email (<a href="mailto:t0hashvein@gmail.com">t0hashvein@gmail.com</a>), Twitter (<a href="http://twitter.com/t0ha666">@t0ha666</a>), Reddit (/u/t0ha) or Telegram (t.me/war1and).<br>See you next time…</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=293645f38145" width="1" height="1" alt=""><hr><p><a href="https://medium.com/3-elm-erlang-elixir/how-to-deploying-phoenix-application-on-ubuntu-293645f38145">How To: Deploying Phoenix Application on Ubuntu</a> was originally published in <a href="https://medium.com/3-elm-erlang-elixir">3∑: Elm, Erlang &amp; Elixir</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
