---
layout: post
title: AWS architecture design for Phoenix app
tag:
- phoenix-framework
- devops
- development
- elixir
- aws
---

<h4>Intro</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/764/1*sGUKG35TnuO3mWyIKJ683w.png" /></figure><p>Imagine you have just finished developing your brilliant startup on Phoenix.</p><p>What’s the next step? Yes, you are right. It’s time to test it and show to its first users.</p><p>In the <a href="https://medium.com/3-elm-erlang-elixir/how-to-deploying-phoenix-application-on-ubuntu-293645f38145">previous article</a>, I’ve shown the way to deploy the application to an Ubuntu server: everything to one place. This way is rather good if your project’s load is not very high.</p><p>But what if it grows? Then it needs to be scalable enough to handle as many customers as needed. This is where Amazon Web Services come to the scene.</p><p>In this article, I will guide you through creating suitable AWS architecture for your basic Phoenix project.</p><h4>Requirements</h4><p>To move forward with this tutorial you need:</p><ul><li>a Phoenix application that has at least 1 Schema</li><li>git repository, preferably, hosted on GitHub</li><li>Amazon Web Services console account.</li></ul><h4>Overview</h4><p>In this tutorial, we are going to create AWS architecture shown in the picture above.</p><p>In Part 1, we’ll make our app to work in AWS in the following way. Our application will work in ECS container which will connect to RDS Postgres DB instance and S3 bucket for uploaded assets. Users will connect to our application through https serving by CloudFront.</p><p>To make things easier, in Part 2, we are going to set up continuous integration with Code Pipeline. It will take source code from our GitHub repo after any update of the ‘deploy’ branch. Then it will build the code, run dyalizer and tests. If they fail it will inform the Project manager by email. Otherwise, will build a release and deploy it to a staging container with temporary DB. When it’s ready, it will inform QA to test and accept production deploy. After deploy is accepted the pipeline will spin up container connected to RDS DB and that’s it.</p><p>In Part 3, we are going to create CloudFormation stack for all this stuff and discuss some alternatives to it.</p><h4>PS</h4><p>Dear readers, thank you for your interest and feedback.</p><p>You are welcome to support this article by clapping, subscribing to the publication or following <a href="https://medium.com/u/a641915f510a">T0ha</a>.</p><p>Do you have a tech startup idea? Or do you need some help with web, mobile or IoT programming?</p><p>Visit <a href="https://3epsilon.pro?utm_source=medium&amp;utm_medium=post&amp;utm_compaign=footer&amp;utm_content=ac090acd91b3">3∑ website</a> and get a great offer from us.</p><p>You can contact me by Email (ceo@3epsilon.pro), Twitter (@t0ha666), Reddit (/u/t0ha) or Telegram (t.me/war1and).</p><p>See you next time…</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ac090acd91b3" width="1" height="1" alt=""><hr><p><a href="https://medium.com/3-elm-erlang-elixir/aws-architecture-design-for-phoenix-app-ac090acd91b3">AWS architecture design for Phoenix app</a> was originally published in <a href="https://medium.com/3-elm-erlang-elixir">3∑: Elm, Erlang &amp; Elixir</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
